## 초기 방향 설정
1번 정점에서 N번 정점까지 가는 최소 비용을 구하는 문제이므로 다익스트라를 변형시키면 되지 않을까 생각했습니다.
1에서 각 정점 v까지 가는 경로의 (K + 1)번째로 큰 비용들의 최솟값을 비교하면 될 것이라 생각했는데 잘못된 생각이었습니다.
다익스트라 알고리즘은 우선순위 큐에서 빠져나오는 정점이 항상 최소 경로가 확정되었을 때여야 하는데
이 문제는 각 정점의 최소 경로가 꼭 그 다음 방문 정점의 최소 경로에 영향을 주지 않기 때문에 위 아이디어로는 풀이가 불가능합니다.
그렇다면 각 경로의 (K + 1)번째의 값들을 비교하기 위해서는 bfs/dfs를 사용해 경로를 실제로 기록해놔야 하는데 이는 너무 많은 메모리를 차지합니다.

<br>

## 문제 아이디어
1번 정점에서 N번 정점까지 도달하는 경로가 있다면 그 중 최소 비용을, 아니라면 -1을 출력하는 문제입니다.
입력으로 들어오는 각 간선의 비용들을 벡터에 따로 담아놓은 뒤, 오름차순으로 정렬합니다.
가장 작은 비용부터 차례대로 탐색해도 되지만, 시간 단축을 위해 이진 탐색을 사용했습니다.
지정된 비용 x에 대해 다익스트라 알고리즘을 실행합니다.
우선순위 큐에서 가장 비용이 작은 정점 u를 추출합니다.
해당 u에서 방문할 수 있는 간선 중 그 비용이 x보다 크다면 가중치 1을, 작거나 같다면 가중치 0을 부여합니다.
음의 가중치가 아니기 때문에 다익스트라 알고리즘이 정상적으로 작동할 것입니다.
만약 dist[v] <= u.d + (x > w(u, v)) 이라면 이미 v로 방문하는 더 작은 비용의 경로가 존재한다는 뜻이므로 우선순위 큐에 삽입하지 않습니다.

최종적으로 dist[N]의 값이 K보다 크다면 해당 비용 x가 정답이 될 수 없으므로 더 큰 비용을 탐색하고 K보다 작거나 같다면 더 작은 비용이 정답이 될 수 있는지 탐색합니다.

<br>

## 시간 복잡도

비용 벡터 정렬: O(NlogN) 
<br>
이진 탐색: O(logP) 
<br>
다익스트라 알고리즘: O((N + P)logV)
<br>
최종 시간 복잡도: O((N + P)logV*logP) (1 <= P <= 10,000, 1 <= N <= 1,000)