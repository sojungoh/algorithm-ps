
## 3. 주사위 고르기

### ✅ 문제 분석
* n개의 주사위 (n은 2의 배수이며, 2와 10 사이 값)가 있다.

* 각 주사위의 6면에는 1부터 100 사이의 숫자가 쓰여 있다.

* 플레이어 A가 (n / 2) 개의 주사위를 가져가면, 나머지를 플레이어 B가 가져간다.

* 가져간 주사위에서 나올 수 있는 모든 경우의 수를 계산한다.

* A가 B에게 이길 확률이 가장 높은 주사위 조합을 출력한다.

<br/>

> 최대 합은 각 주사위 6면이 모두 100이고 각 플레이어가 가져간 주사위가 5개일 때 100 * 6 * 5 = 3000이므로 sum의 변수 타입은 int여도 된다.

> 최대 주사위 조합 수 : 10C5 = 252

> 최대 게임 경우의 수 : 6^5 * 6^5 = 7,776

<br/>

### ✅ 알고리즘 설계
* 모든 주사위 조합을 계산해 벡터에 담는 함수 구현
    * 주사위는 1 ~ n까지의 숫자를 순차적으로 부여받음
    * recursive하게 구현
    * A가 i번째 주사위 조합을 가지면, B는 (n - 1 - i)번째 주사위 조합을 가짐

* 주사위 조합에 따라 모든 게임 경우의 수의 sum을 담은 벡터를 return하는 함수 구현
    * recursive하게 구현
    * 주사위 하나에서 값 하나 선택 후, 다음 주사위에서도 값 선택하는 과정을 반복
    * n /2 개의 값이 선택되면 vector에 sum값 넣고 return

* sum 벡터를 오름차순으로 정렬한 후 승패 개수 세고 승 개수가 더 많은 주사위 조합을 임시 정답으로 처리한 후 위 과정을 반복하며 정답값을 비교하고 최종 answer 도출

<br/>

### ✅ 시간 복잡도
* **piciking_dice** : O(n^2)
* **while문** : nCn/2 = O(n)
* **sum_dice** : 6n = O(n)
* **sort** : arr size가 O(n)이므로 O(nlogn)
* **lower_bound** : O(logn)

따라서, 총 시간 복잡도는 O(n) * O(nlogn) = O(n^2logn) 이다.
해당 문제에서는 n의 최댓값이 10이라 시간복잡도를 고려할 필요가 없으나, 1초 정도의 시간 제한이 있을 때 n=10^4 일 때까지는 해당 풀이로 고려해볼만 하다.

<br/>

### ✅ 부족했던 부분
* 구현 능력 부족
* 주사위 조합과 sum 경우의 수 값을 한 번에 계산하려고 해서 복잡해졌다. 코드 모듈화에 신경쓰자.

### ✅ 추가 공부
* combination & permutation
* lower_bound & upper_bound
* recursive func

