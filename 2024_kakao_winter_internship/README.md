
## 3. 주사위 고르기

### ✅ 문제 분석
* n개의 주사위 (n은 2의 배수이며, 2와 10 사이 값)가 있다.

* 각 주사위의 6면에는 1부터 100 사이의 숫자가 쓰여 있다.

* 플레이어 A가 (n / 2) 개의 주사위를 가져가면, 나머지를 플레이어 B가 가져간다.

* 가져간 주사위에서 나올 수 있는 모든 경우의 수를 계산한다.

* A가 B에게 이길 확률이 가장 높은 주사위 조합을 출력한다.

<br/>

> 최대 합은 각 주사위 6면이 모두 100이고 각 플레이어가 가져간 주사위가 5개일 때 100 * 6 * 5 = 3000이므로 sum의 변수 타입은 int여도 된다.

> 최대 주사위 조합 수 : 10C5 = 252

> 최대 게임 경우의 수 : 6^5 * 6^5 = 7,776

<br/>

### ✅ 알고리즘 설계
* 모든 주사위 조합을 계산해 벡터에 담는 함수 구현
    * 주사위는 1 ~ n까지의 숫자를 순차적으로 부여받음
    * recursive하게 구현
    * A가 i번째 주사위 조합을 가지면, B는 (n - 1 - i)번째 주사위 조합을 가짐

* 주사위 조합에 따라 모든 게임 경우의 수의 sum을 담은 벡터를 return하는 함수 구현
    * recursive하게 구현
    * 주사위 하나에서 값 하나 선택 후, 다음 주사위에서도 값 선택하는 과정을 반복
    * n /2 개의 값이 선택되면 vector에 sum값 넣고 return

* sum 벡터를 오름차순으로 정렬한 후 승패 개수 세고 승 개수가 더 많은 주사위 조합을 임시 정답으로 처리한 후 위 과정을 반복하며 정답값을 비교하고 최종 answer 도출

<br/>

### ✅ 시간 복잡도
* **piciking_dice** : O(n^2)
* **while문** : nCn/2 = O(n)
* **sum_dice** : 6n = O(n)
* **sort** : arr size가 O(n)이므로 O(nlogn)
* **lower_bound** : O(logn)

따라서, 총 시간 복잡도는 O(n) * O(nlogn) = O(n^2logn) 이다.
해당 문제에서는 n의 최댓값이 10이라 시간복잡도를 고려할 필요가 없으나, 1초 정도의 시간 제한이 있을 때 n=10^4 일 때까지는 해당 풀이로 고려해볼만 하다.

### ✅ 부족했던 부분
* 구현 능력 부족
* 주사위 조합과 sum 경우의 수 값을 한 번에 계산하려고 해서 복잡해졌다. 코드 모듈화에 신경쓰자.

### ✅ 추가 공부
* combination & permutation
* lower_bound & upper_bound
* recursive func

<br/>

## 4. n + 1 카드게임

### ✅ 문제 분석
* n장의 카드와 coin개의 동전이 있다. (n은 1000보다 작고 6의 배수이며 coin은 n보다 작거나 같음)

* 초기 세팅: cards 벡터에 앞부터 순차적으로 n/3 장을 가진 채로 게임이 시작된다.

* 남은 카드 (2n / 3)장 중 앞부터 순차적으로 2개씩 가져온다.
    * 만약 남은 카드가 없으면 해당 라운드에서 게임 종료

* 동전 하나 당 카드 하나를 가져올 수 있다.

* 카드 합이 (n + 1)이 되는 두 장을 낸다.
    * 낼 카드가 없으면 해당 라운드에서 게임 종료

* 정답: 최대 라운드의 수

<br/>

### ✅ 알고리즘 설계
* 매 라운드에서 동전을 최대한 적게 쓰는 것이 핵심이다.
    * 동전은 한 라운드 당 0, 1, 2개 사용이 가능하다.

* 동전 0개로 넘어가는 경우
    * 현재 내 카드 중 합이 (n + 1)이 되는 카드 짝이 있을 때
    * 이 경우, 꼭 해당 라운드에서 카드를 가지고 올 필요는 없지만 다음을 대비해 필요할 수도 있음
    * 모든 경우의 수를 세보지 말고 next_cards 벡터에 넣어놓음

* 동전 1개로 넘어가는 경우
    * 현재 내 카드 중 합이 (n + 1)이 되는 카드 짝이 없고, 지금까지 지나온 라운드에 있었던 카드 집합 중에서 하나가 내 카드와의 합이 (n + 1)이 될 때
    * next_cards 벡터에서 하나를 고르고 동전 개수를 하나 줄임

* 동전 2개로 넘어가는 경우
    * 현재 내 카드와 지나온 라운드에 있었던 카드 집합의 합이 (n + 1)이 되지 못하고 지나온 라운드에 있었던 두 개의 카드 합이 (n + 1)이 될 때
    * next_cards 벡터에서 그러한 경우 2개를 꺼내고 동전 개수를 두 개 줄임

* 위 3가지 조건을 충족하지 못하면 게임 종료

<br/>

### ✅ 시간 복잡도
* O(n^2)

n이 10^4 이하이면 1초 안에 수행 가능 <br/>
문제에서 n은 1,000보다 작다 하였으므로 통과

### ✅ 부족했던 부분
* 해당 라운드에서 뽑은 카드 2장을 모아둔다는 아이디어를 생각 못하고 모든 경우의 수를 구해보려 했다.


### ✅ 추가 공부